---
globs: 
  - "src/views/**/*.vue"
  - "src/components/**/*.vue"
alwaysApply: false
description: 前端开发规范 Vue3 组合式API
keywords: ["vue3", "composition-api", "组合式api", "响应式", "pinia", "路由", "vue组件"]
tags: ["vue3", "composition-api", "基础规范"]
size: medium
---

# 销售系统 Vue 3 开发模式规范

## Vue 3 + Composition API 规范

### 1. 组件结构规范

```vue
<template>
  <!-- 模板内容 -->
</template>

<script setup>
// 导入依赖
import { ref, reactive, computed, onMounted } from "vue";
import { useRouter } from "vue-router";

// 响应式数据
const loading = ref(false);
const formData = reactive({
  name: "",
  description: "",
});

// 计算属性
const isValid = computed(() => {
  return formData.name.trim() !== "";
});

// 方法
const handleSubmit = async () => {
  // 处理逻辑
};

// 生命周期
onMounted(() => {
  // 初始化逻辑
});
</script>

<style lang="scss" scoped>
/* 样式内容 */
</style>
```

#### 1.1 组件命名规范

**⚠️ 重要：禁止自主使用 defineOptions 定义路由 name！**

路由的 name 应由路由配置文件统一管理，不应在组件中随意使用 defineOptions 定义。

```vue
<!-- ❌ 错误方式 - 禁止在组件中使用 defineOptions -->
<script setup>
import { defineOptions } from 'vue'

defineOptions({
  name: 'ComponentName' // ❌ 禁止这样做！
})
</script>

<!-- ✅ 正确方式 - 不在组件中定义路由 name -->
<script setup>
// 组件代码
</script>
```

**规范说明：**

- 路由的 name 应在 `router/index.js` 或对应的路由配置文件中定义
- 组件不需要使用 `defineOptions` 定义组件名称
- 保持路由管理的集中化和统一性

### 2. 代码注释规范

#### 2.1 文件头注释规范

**⚠️ 重要：所有新建文件必须在文件头部添加文件头注释（File Header Comment）**

##### Vue 组件文件（.vue）

```vue
<!--
 * @Date: 2025-12-18 10:45:50
 * @Author: mxy
-->
```

##### JavaScript/TypeScript 文件（.js/.ts/.jsx/.tsx）

```javascript
/*
 * @Date: 2025-12-18 10:45:50
 * @Author: mxy
 */
```

##### 注释要求

1. **@Date（必需）**：
   - 格式：`yyyy-MM-dd HH:mm:ss`
   - 值：文件创建时的实际时间
   - 生成方式：使用当前系统时间，格式为 `yyyy-MM-dd HH:mm:ss`
   - 示例：`2025-12-18 10:45:50`

2. **@Author（必需）**：
   - 值：文件创建人的 Git 用户名
   - 获取方式：通过 `git config user.name` 命令获取
   - 示例：`mxy`

3. **注释位置**：
   - Vue 文件：使用 HTML 注释 `<!-- -->`，放在 `<template>` 标签之前
   - JS/TS 文件：使用 JavaScript 注释 `/* */`，放在文件最顶部

##### AI 助手自动生成规范

当 AI 助手创建新文件时，必须：

1. **获取当前时间**：
   ```bash
   powershell -Command "Get-Date -Format 'yyyy-MM-dd HH:mm:ss'"
   # 或使用系统当前时间
   ```

2. **获取 Git 用户名**：
   ```bash
   git config user.name
   ```

3. **自动生成文件头注释**：
   - 使用获取到的时间作为 `@Date` 值
   - 使用获取到的 Git 用户名作为 `@Author` 值
   - 按照文件类型使用对应的注释格式

##### 示例

```vue
<!-- ✅ 正确方式 - Vue 文件 -->
<!--
 * @Date: 2025-12-18 10:45:50
 * @Author: mxy
-->
<template>
  <!-- 组件内容 -->
</template>
```

```javascript
/* ✅ 正确方式 - JS 文件 */
/*
 * @Date: 2025-12-18 10:45:50
 * @Author: mxy
 */
export const listData = {
  // 代码内容
}
```

#### 2.2 JSDoc 注释规范

**⚠️ 重要：所有公开的函数、方法、类必须添加 JSDoc 注释**

##### 基本格式

```javascript
/**
 * 函数描述
 * @param {类型} 参数名 - 参数描述
 * @returns {类型} 返回值描述
 */
```

##### 常用标签说明

1. **@param**：参数说明
   - **基本格式**：`@param {类型} 参数名 - 参数描述`
   - **复杂对象格式**：
     ```javascript
     /**
      * @param {Object} 参数名 - 参数描述
      * @param {类型} 参数名.属性名 - 属性描述
      * @param {类型} 参数名.属性名 - 属性描述
      */
     ```
   - **数组格式**：`@param {Array<类型>} 参数名 - 参数描述`
   - **可选参数**：`@param {类型} [参数名] - 参数描述（可选）`

2. **@returns**：返回值说明
   - **基本格式**：`@returns {类型} 返回值描述`
   - **Promise 格式**：`@returns {Promise<类型>} 返回值描述`
   - **无返回值**：`@returns {void}`

3. **@description**：详细描述（可选）
   - **格式**：`@description 详细描述内容`
   - **使用场景**：当函数描述需要多行详细说明时使用

##### 完整示例

**示例 1：基本函数注释**

```javascript
/**
 * 根据ID获取用户信息
 * @param {string} userId - 用户ID
 * @returns {Promise<Object>} 返回用户信息对象
 */
export function getUserInfo(userId) {
  return request({
    url: `/api/user/${userId}`,
    method: 'get'
  })
}
```

**示例 2：复杂对象参数**

```javascript
/**
 * 根据合同ID查询完整签署配置信息
 * @param {Object} data - 查询参数对象
 * @param {string} data.contractId - 地方合同ID
 * @param {number} [data.pageNum] - 页码（可选）
 * @param {number} [data.pageSize] - 每页数量（可选）
 * @returns {Promise<Object>} 返回完整签署配置信息
 */
export function fetchCompleteSignConfig(params) {
  return request({
    url: `/sale/houseOffset/qiyuesuoConfig/${data.contractId}`,
    method: 'get',
    params
  })
}
```

**示例 3：数组参数**

```javascript
/**
 * 批量删除用户
 * @param {Array<string>} userIds - 用户ID数组
 * @returns {Promise<Object>} 返回删除结果
 */
export function batchDeleteUsers(userIds) {
  return request({
    url: '/api/user/batchDelete',
    method: 'post',
    data: userIds
  })
}
```

##### 常见类型

- `{string}` - 字符串
- `{number}` - 数字
- `{boolean}` - 布尔值
- `{Object}` - 对象
- `{Array}` - 数组
- `{Function}` - 函数
- `{Promise<Object>}` - Promise 对象
- `{void}` - 无返回值

##### 规范要求

1. **所有公开的 API 函数必须添加 JSDoc 注释**
2. **参数说明必须包含类型、参数名和描述**
3. **返回值必须说明类型和含义**
4. **复杂参数应该详细说明对象属性**

##### 错误示例

```javascript
// ❌ 错误方式 - 缺少注释
export function fetchData(id) {
  return request({ url: `/api/data/${id}` })
}

// ❌ 错误方式 - 注释不完整
/**
 * 获取数据
 */
export function fetchData(id) {
  return request({ url: `/api/data/${id}` })
}

// ✅ 正确方式 - 完整 JSDoc 注释
/**
 * 根据ID获取数据
 * @param {string} id - 数据ID
 * @returns {Promise<Object>} 返回数据对象
 */
export function fetchData(id) {
  return request({ url: `/api/data/${id}` })
}
```

### 3. 响应式数据管理

#### 2.1 ref 和 reactive 使用规范

```javascript
// 基本类型使用 ref
const count = ref(0);
const name = ref("");
const loading = ref(false);

// 对象类型使用 reactive
const formData = reactive({
  name: "",
  email: "",
  phone: "",
});

// 数组使用 ref
const list = ref([]);
const selectedItems = ref([]);
```

#### 2.2 响应式数据解构

```javascript
// 错误方式 - 会失去响应性
const { name, email } = formData;

// 正确方式 - 使用 toRefs
import { toRefs } from "vue";
const { name, email } = toRefs(formData);

// 或者使用 computed
const name = computed(() => formData.name);
const email = computed(() => formData.email);
```

### 4. 组合式函数 (Composables)

#### 3.1 项目现有Hooks

```javascript
// hooks/useTableCommon.js - TableCommon组件专用Hook
import { computed, toRef } from "vue";
import { getCustomTableData } from "@/api/customTable";

export function useTableCommon(listData) {
  const _listData = computed(() => {
    // 处理按钮显示逻辑
    const processedData = { ...listData.value };
    // 按钮权限控制逻辑
    return processedData;
  });

  const api = computed(() => {
    if (!_listData.value) return null;
    return _listData.value.api;
  });

  return {
    api,
    _listData
  };
}

// hooks/useHasPermi.js - 权限控制Hook
import useUserStore from '@/store/modules/user';
import { storeToRefs } from 'pinia';

export const useHasPermi = () => {
  const userUser = useUserStore();
  const { permissions } = storeToRefs(userUser);

  const hasAccess = value => {
    if (value) {
      const all_permission = '*:*:*';
      const hasPermission = all_permission === value || permissions.value.includes(value);
      return hasPermission;
    }
    return true;
  };

  return { hasAccess };
};

// hooks/useStyleConfig.js - 样式配置Hook
import styleConfig from '@/enums/styleConfig';

export const useStyleConfig = () => {
  return { ...styleConfig };
};

#### 3.3 字典使用规范

**⚠️ 重要：字典使用必须通过 proxy.useDict**

```javascript
// ✅ 正确方式
const { proxy } = getCurrentInstance()
const { key1, key2 } = proxy.useDict('key1', 'key2')

// ❌ 错误方式 - 不要单独引入 useDict
// import { useDict } from '@/hooks/useDict'
```

**详细规范说明**：
- 通用字典使用规范请参考本规范
- TableCommon 组件中的字典使用规范（包含 dictStore 传递等）请参考 [TableCommon-项目规则.mdc](./TableCommon-项目规则.mdc) 中的"字典使用规范"章节

**⚠️ 重要规范：样式配置统一使用 useStyleConfig**

**核心原则**：
- ✅ el-form 的布局、el-col 的 span 栅格、el-dialog 的弹窗宽度全部统一使用 `useStyleConfig` 这个 hooks 函数的默认配置变量
- ❌ 禁止手动设置 el-form、el-col、el-dialog 的样式配置

```vue
<!-- ✅ 正确方式 - 使用 useStyleConfig 统一配置 -->
<template>
  <el-dialog
    v-model="visible"
    :title="dialogTitle"
    :width="MODAL_CONFIG['pro']"
    destroy-on-close
    append-to-body
  >
    <el-form
      ref="formRef"
      v-bind="FORM_CONFIG.defaultConfig"
      :model="formData"
      :rules="rules"
    >
      <el-row :gutter="16">
        <el-col v-bind="LAYOUT_CONFIG.colSpan">
          <el-form-item label="姓名" prop="name">
            <el-input v-model="formData.name" />
          </el-form-item>
        </el-col>
        <el-col v-bind="LAYOUT_CONFIG.colSpan">
          <el-form-item label="邮箱" prop="email">
            <el-input v-model="formData.email" />
          </el-form-item>
        </el-col>
      </el-row>
    </el-form>
  </el-dialog>
</template>

<script setup>
import { useStyleConfig } from '@/hooks/useStyleConfig';

// 统一使用 useStyleConfig 获取样式配置
const { MODAL_CONFIG, FORM_CONFIG, LAYOUT_CONFIG } = useStyleConfig();
</script>
```

```vue
<!-- ❌ 错误方式 - 手动设置样式配置 -->
<template>
  <el-dialog
    v-model="visible"
    :width="800"
    <!-- ❌ 禁止：手动设置宽度 -->
  >
    <el-form
      label-width="120px"
      <!-- ❌ 禁止：手动设置 label-width -->
    >
      <el-row :gutter="20">
        <!-- ❌ 禁止：手动设置 gutter -->
        <el-col :span="12">
          <!-- ❌ 禁止：手动设置 span -->
        </el-col>
      </el-row>
    </el-form>
  </el-dialog>
</template>
```

// hooks/useTableListFunc.js - 表格操作Hook
export const useTableListFunc = () => {
  const commonFunc = (apiFunction, apiParams, successCallback, modalContent, errCallBack) => {
    // 通用确认操作逻辑
  };

  const removeFunc = (apiFunction, apiParams, successCallback, modalContent) => {
    // 删除操作逻辑
  };

  return {
    commonFunc,
    removeFunc
  };
};
```

#### 3.4 使用组合式函数

```vue
<template>
  <div class="table-container">
    <!-- 搜索表单 -->
    <el-form :model="queryParams" inline>
      <el-form-item label="关键词">
        <el-input v-model="queryParams.keyword" placeholder="请输入关键词" />
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click="handleSearch">搜索</el-button>
        <el-button @click="handleReset">重置</el-button>
      </el-form-item>
    </el-form>

    <!-- 数据表格 -->
    <el-table v-loading="loading" :data="data">
      <!-- 表格列 -->
    </el-table>

    <!-- 分页 -->
    <el-pagination
      v-model:current-page="queryParams.pageNum"
      v-model:page-size="queryParams.pageSize"
      :total="total"
      @current-change="handlePageChange"
    />
  </div>
</template>

<script setup>
import { onMounted } from "vue";
import { useTable } from "@/hooks/useTable";
import { fetchUserList } from "@/api/system/user";

const {
  loading,
  data,
  total,
  queryParams,
  fetchData,
  handleSearch,
  handleReset,
  handlePageChange,
} = useTable(fetchUserList);

onMounted(() => {
  fetchData();
});
</script>
```

### 5. 状态管理 (Pinia)

#### 5.1 项目现有Store模块

```javascript
// store/modules/user.js - 用户状态管理
import { login, logout, getInfo, loginByPhone } from '@/api/login';
import { getToken, setToken, removeToken } from '@/utils/auth';

const useUserStore = defineStore('user', {
  state: () => ({
    token: getToken(),
    name: '',
    avatar: '',
    userInfo: null,
    roles: [],
    permissions: []
  }),
  actions: {
    login(userInfo) {
      // 登录逻辑
    },
    logout() {
      // 登出逻辑
    },
    getInfo() {
      // 获取用户信息
    }
  }
});

// store/modules/permission.js - 权限状态管理
const usePermissionStore = defineStore('permission', {
  state: () => ({
    routes: [],
    addRoutes: [],
    defaultRoutes: [],
    topbarRouters: [],
    sidebarRouters: []
  }),
  actions: {
    setRoutes(routes) {
      this.addRoutes = routes;
      this.routes = constantRoutes.concat(routes);
    }
  }
});

// store/modules/settings.js - 设置状态管理
const useSettingsStore = defineStore('settings', {
  state: () => ({
    title: '',
    theme: '#409EFF',
    sideTheme: 'dark',
    showSettings: true,
    topNav: false,
    tagsView: true,
    fixedHeader: false,
    sidebarLogo: true,
    dynamicTitle: false
  }),
  actions: {
    changeSetting(data) {
      const { key, value } = data;
      if (Object.hasOwnProperty.call(this, key)) {
        this[key] = value;
      }
    }
  },
  persist: {
    enabled: true,
    strategies: [{
      key: 'settings',
      storage: localStorage
    }]
  }
});

// store/modules/dict.js - 字典状态管理
const useDictStore = defineStore('dict', {
  state: () => ({
    dict: new Array()
  }),
  actions: {
    getDict(_key) {
      // 获取字典数据
    },
    setDict(_key, value) {
      // 设置字典数据
    },
    removeDict(_key) {
      // 删除字典数据
    }
  }
});
```

#### 5.2 在组件中使用 Store

```vue
<template>
  <div class="user-management">
    <el-table v-loading="userStore.loading" :data="userStore.userList">
      <!-- 表格内容 -->
    </el-table>
  </div>
</template>

<script setup>
import { onMounted } from "vue";
import { useUserStore } from "@/stores/user";

const userStore = useUserStore();

onMounted(() => {
  userStore.fetchUserList({
    pageNum: 1,
    pageSize: 10,
  });
});
</script>
```

### 6. 路由管理

#### 6.1 路由定义规范

```javascript
// router/index.js
import { createRouter, createWebHistory } from "vue-router";

const routes = [
  {
    path: "/portal",
    component: () => import("@/layout/PortalLayout.vue"),
    children: [
      {
        path: "home",
        name: "PortalHome",
        component: () => import("@/views/portal/home/index.vue"),
        meta: {
          title: "首页",
          requiresAuth: false,
        },
      },
      {
        path: "goods",
        name: "PortalGoods",
        component: () => import("@/views/portal/goods/index.vue"),
        meta: {
          title: "商品展示",
          requiresAuth: false,
        },
      },
      {
        path: "case",
        name: "PortalCase",
        component: () => import("@/views/portal/case/index.vue"),
        meta: {
          title: "案例展示",
          requiresAuth: false,
        },
      },
    ],
  },
  {
    path: "/admin",
    component: () => import("@/layout/index.vue"),
    meta: {
      requiresAuth: true,
    },
    children: [
      {
        path: "user",
        name: "AdminUser",
        component: () => import("@/views/admin/user/index.vue"),
        meta: {
          title: "用户管理",
          requiresAuth: true,
        },
      },
    ],
  },
];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

export default router;
```

#### 6.2 路由导航

```javascript
// 在组件中使用路由
import { useRouter, useRoute } from "vue-router";

const router = useRouter();
const route = useRoute();

// 编程式导航
const goToDetail = (id) => {
  router.push({
    name: "UserDetail",
    params: { id },
  });
};

// 带查询参数
const goToList = (params) => {
  router.push({
    name: "UserList",
    query: params,
  });
};

// 获取路由参数
const userId = route.params.id;
const queryParams = route.query;
```

### 7. 事件处理

#### 7.1 事件处理规范

```vue
<template>
  <div class="event-handlers">
    <!-- 点击事件 -->
    <el-button @click="handleClick">点击</el-button>

    <!-- 表单提交 -->
    <el-form @submit.prevent="handleSubmit">
      <el-button type="submit">提交</el-button>
    </el-form>

    <!-- 自定义事件 -->
    <child-component @custom-event="handleCustomEvent" />

    <!-- 键盘事件 -->
    <el-input @keyup.enter="handleEnter" />
  </div>
</template>

<script setup>
const handleClick = (event) => {
  console.log("点击事件", event);
};

const handleSubmit = () => {
  console.log("表单提交");
};

const handleCustomEvent = (data) => {
  console.log("自定义事件", data);
};

const handleEnter = () => {
  console.log("回车键");
};
</script>
```

### 8. 表单处理

#### 8.1 表单验证

```vue
<template>
  <el-form ref="formRef" v-bind="FORM_CONFIG.defaultConfig" :model="formData" :rules="rules">
    <el-form-item label="用户名" prop="username">
      <el-input v-model="formData.username" />
    </el-form-item>

    <el-form-item label="邮箱" prop="email">
      <el-input v-model="formData.email" />
    </el-form-item>

    <el-form-item>
      <el-button type="primary" @click="handleSubmit">提交</el-button>
      <el-button @click="handleReset">重置</el-button>
    </el-form-item>
  </el-form>
</template>

<script setup>
import { ref, reactive } from "vue";

const formRef = ref();
const formData = reactive({
  username: "",
  email: "",
});

const rules = {
  username: [
    { required: true, message: "请输入用户名", trigger: "blur" },
    { min: 3, max: 20, message: "长度在 3 到 20 个字符", trigger: "blur" },
  ],
  email: [
    { required: true, message: "请输入邮箱", trigger: "blur" },
    { type: "email", message: "请输入正确的邮箱格式", trigger: "blur" },
  ],
};

const handleSubmit = async () => {
  try {
    await formRef.value.validate();
    // 提交逻辑
    proxy.$modal.msgSuccess("提交成功");
  } catch (error) {
    proxy.$modal.msgError("表单验证失败");
  }
};

const handleReset = () => {
  formRef.value.resetFields();
};
</script>
```

#### 8.2 el-form 表单布局规范

**⚠️ 重要：el-form 标签下默认有且只能有一对儿 el-row 的开闭合标签对儿。**

```vue
<!-- ✅ 正确方式 - el-form下只有一对el-row -->
<el-form
  ref="formRef"
  v-bind="FORM_CONFIG.defaultConfig"
  :model="formData"
  :rules="rules"
>
  <el-row :gutter="16">
    <el-col v-bind="LAYOUT_CONFIG.colSpan">
      <el-form-item label="字段1" prop="field1">
        <el-input v-model="formData.field1" />
      </el-form-item>
    </el-col>
    <el-col v-bind="LAYOUT_CONFIG.colSpan">
      <el-form-item label="字段2" prop="field2">
        <el-input v-model="formData.field2" />
      </el-form-item>
    </el-col>
  </el-row>
</el-form>

<!-- ❌ 错误方式 - el-form下有多对el-row -->
<el-form
  ref="formRef"
  v-bind="FORM_CONFIG.defaultConfig"
  :model="formData"
  :rules="rules"
>
  <el-row :gutter="16">
    <el-col v-bind="LAYOUT_CONFIG.colSpan">
      <el-form-item label="字段1" prop="field1">
        <el-input v-model="formData.field1" />
      </el-form-item>
    </el-col>
  </el-row>
  <el-row :gutter="16">
    <el-col v-bind="LAYOUT_CONFIG.colSpan">
      <el-form-item label="字段2" prop="field2">
        <el-input v-model="formData.field2" />
      </el-form-item>
    </el-col>
  </el-row>
</el-form>
```

**配置说明：**

- **单一布局**: el-form 下只能有一对 el-row 标签
- **统一间距**: 使用统一的 gutter 值（通常为 16）
- **响应式布局**: 使用 LAYOUT_CONFIG.colSpan 配置列宽
- **表单验证**: 保持表单验证规则的完整性

### 9. 异步处理

#### 9.1 async/await 规范

```javascript
// 异步函数处理
const fetchData = async () => {
  loading.value = true;
  try {
    const response = await api.getData();
    data.value = response.data;
  } catch (error) {
    proxy.$modal.msgError("获取数据失败");
    console.error(error);
  } finally {
    loading.value = false;
  }
};

// 并行请求
const fetchAllData = async () => {
  try {
    const [users, roles] = await Promise.all([fetchUsers(), fetchRoles()]);
    userList.value = users.data;
    roleList.value = roles.data;
  } catch (error) {
    proxy.$modal.msgError("获取数据失败");
  }
};
```

### 10. 组件通信

#### 10.1 父子组件传值规范（defineModel）

**⚠️ 重要规范：子组件统一使用 `defineModel` 接收数据，父组件传递完整的 formData 对象**

**核心原则**：
- ✅ 子组件统一使用 `const modelValue = defineModel({type: Object, required: true})` 来接收
- ✅ 父组件定义全量字段的 formData 对象，通过 v-model 传递 formData 整个对象
- ❌ 拒绝出现传递 `formData.List` 这种某个属性的情况，除非子组件内就是纯展示没有其他业务逻辑
- ❌ 禁止使用 emit(事件)去更新父组件 formData 内属性

```vue
<!-- ✅ 正确方式 - 父组件传递完整 formData -->
<template>
  <div class="parent-component">
    <!-- 传递完整的 formData 对象 -->
    <child-component v-model="formData" />
    <brother-component v-model="formData" />
  </div>
</template>

<script setup>
import { reactive } from "vue";
import ChildComponent from "./ChildComponent.vue";
import BrotherComponent from "./BrotherComponent.vue";

// 父组件定义全量字段的 formData 对象
const formData = reactive({
  name: "",
  email: "",
  phone: "",
  address: {
    province: "",
    city: "",
    district: ""
  },
  list: []
});
</script>
```

```vue
<!-- ✅ 正确方式 - 子组件使用 defineModel 接收 -->
<template>
  <div class="child-component">
    <el-form-item label="姓名">
      <el-input v-model="modelValue.name" />
    </el-form-item>
    <el-form-item label="邮箱">
      <el-input v-model="modelValue.email" />
    </el-form-item>
  </div>
</template>

<script setup>
// 统一使用 defineModel 接收完整对象
const modelValue = defineModel({ type: Object, required: true });
</script>
```

```vue
<!-- ✅ 正确方式 - 兄弟组件之间通过 modelValue.value 访问共享数据 -->
<template>
  <div class="brother-component">
    <el-form-item label="电话">
      <el-input v-model="modelValue.phone" />
    </el-form-item>
    <!-- 可以直接访问其他兄弟组件修改的属性 -->
    <div>当前姓名：{{ modelValue.name }}</div>
  </div>
</template>

<script setup>
// 兄弟组件也使用 defineModel 接收同一个 formData
const modelValue = defineModel({ type: Object, required: true });

// 可以直接访问和修改 formData 中的任何属性
// 实现父子、兄弟组件之间的数据双向绑定/共享
const updatePhone = () => {
  modelValue.value.phone = "13800138000";
};
</script>
```

```vue
<!-- ❌ 错误方式 - 传递 formData 的某个属性 -->
<template>
  <child-component v-model="formData.list" />
  <!-- ❌ 禁止：只传递 formData 的某个属性 -->
</template>

<!-- ❌ 错误方式 - 使用 props 接收 -->
<script setup>
// ❌ 禁止：使用 props 接收，应该使用 defineModel
const props = defineProps({
  formData: {
    type: Object,
    required: true
  }
});
</script>

<!-- ❌ 错误方式 - 使用 emit 更新父组件数据 -->
<script setup>
const emit = defineEmits(['update:formData']);

const updateData = () => {
  // ❌ 禁止：使用 emit 更新父组件 formData 内属性
  emit('update:formData', { name: 'new name' });
};
</script>
```

**特殊情况说明**：
- 如果子组件内**只是纯展示，没有其他业务逻辑**，可以传递 formData 的某个属性
- 但一般情况下，都应该传递完整的 formData 对象

#### 10.2 兄弟组件数据共享

**核心原则**：
- ✅ 各兄弟组件可以通过访问 `modelValue.value` 去访问其他兄弟组件内的属性
- ✅ 实现父子、兄弟组件之间的数据双向绑定/共享等功能
- ❌ 禁止出现 emit(事件)去更新父组件 formData 内属性

```vue
<!-- 父组件 -->
<template>
  <div>
    <!-- 多个兄弟组件共享同一个 formData -->
    <basic-info-component v-model="formData" />
    <contact-info-component v-model="formData" />
    <address-info-component v-model="formData" />
  </div>
</template>

<script setup>
import { reactive } from "vue";

const formData = reactive({
  name: "",
  email: "",
  phone: "",
  address: {}
});
</script>
```

```vue
<!-- 兄弟组件 A - 基础信息 -->
<template>
  <el-form-item label="姓名">
    <el-input v-model="modelValue.name" />
  </el-form-item>
</template>

<script setup>
const modelValue = defineModel({ type: Object, required: true });
</script>
```

```vue
<!-- 兄弟组件 B - 联系信息 -->
<template>
  <el-form-item label="邮箱">
    <el-input v-model="modelValue.email" />
  </el-form-item>
  <!-- 可以直接访问兄弟组件 A 修改的 name 属性 -->
  <div>当前姓名：{{ modelValue.name }}</div>
</template>

<script setup>
const modelValue = defineModel({ type: Object, required: true });

// 可以直接访问和修改 formData 中的任何属性
// 实现兄弟组件之间的数据共享
const syncEmailWithName = () => {
  if (modelValue.value.name) {
    modelValue.value.email = `${modelValue.value.name}@example.com`;
  }
};
</script>
```

#### 10.3 watch 使用规范

**⚠️ 重要规范：尽量少的使用 watch 监听，减少性能消耗**

**核心原则**：
- ✅ 尽量少的使用 watch 监听，减少性能消耗
- ✅ 若必须使用，请在页面销毁时解除监听

```vue
<script setup>
import { ref, watch, onBeforeUnmount } from "vue";

const formData = ref({
  name: "",
  email: ""
});

// ✅ 正确方式 - 必须使用时，在销毁时解除监听
const stopWatch = watch(
  () => formData.value.name,
  (newVal, oldVal) => {
    console.log("name changed:", newVal);
  },
  { immediate: false }
);

// 页面销毁时解除监听
onBeforeUnmount(() => {
  stopWatch();
});

// ❌ 错误方式 - 没有解除监听
watch(
  () => formData.value.name,
  (newVal) => {
    console.log("name changed:", newVal);
  }
);
// 组件销毁后，watch 仍然存在，造成内存泄漏
</script>
```

**watch 使用建议**：
- 优先使用 `computed` 替代 `watch`
- 如果必须使用 `watch`，确保在 `onBeforeUnmount` 中调用返回的停止函数
- 避免在循环或频繁触发的场景中使用 `watch`

### 11. 销售系统特色组件

#### 11.1 TableCommon通用表格组件

```vue
<template>
  <div class="table-container">
    <vxe-grid
      ref="gridRef"
      v-bind="gridOptions"
      :data="tableData"
      :loading="loading"
      @cell-click="handleCellClick"
    >
    </vxe-grid>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, getCurrentInstance } from 'vue';
import { useTableCommon } from '@/components/TableCommon/hooks/useTableCommon';
const { proxy } = getCurrentInstance()

const props = defineProps({
  listData: {
    type: Object,
    required: true
  }
});

const { serviceStatusDict } = proxy.useDict('service_status');
// serviceStatusDict 是个响应式数据， 如需在script中使用：serviceStatusDict.value.map(item=>{})

const tableRef = ref(null);
const loading = ref(false);
const tableData = ref([]);

const { api } = useTableCommon(props.listData);

const gridOptions = computed(() => ({
  columns: props.listData.columns,
  pagerConfig: props.listData.pagerConfig,
  toolbarConfig: props.listData.toolbarConfig
}));

const loadData = async () => {
  if (!api.value) return;
  
  loading.value = true;
  try {
    const res = await getCustomTableData({}, api.value);
    tableData.value = res.records || [];
  } catch (error) {
    console.error('数据加载失败:', error);
  } finally {
    loading.value = false;
  }
};

onMounted(() => {
  loadData();
});
</script>
```



## 🎨 UI规范与交互标准

### 📊 表格组件规范（el-table / TableCommon）

#### 1. 表头对齐规范

表头和单元格的对齐方式应根据内容类型确定，保持视觉一致性和可读性：

| 内容类型 | 对齐方式 | 说明 | 示例 |
|---------|---------|------|------|
| 文本（长短不一） | **左对齐** | 中文/英文文本，长度不固定 | 姓名、地址、备注 |
| 文本（长度相同） | **居中对齐** | 固定长度的文本或状态 | 状态、类型、等级 |
| 数字/金额 | **右对齐** | 所有数值类型数据 | 金额、数量、百分比 |
| 操作列 | **居中对齐** | 操作按钮组 | 编辑、删除、查看 |

**⚠️ 重要规则：**
- ✅ **单位统一放在表头**：`金额(元)`、`面积(㎡)`、`比例(%)`
- ❌ **禁止在单元格中拼接单位**：避免 `100元`、`50%` 这样的写法
- ✅ **数值格式化**：金额使用千分位分隔符且保留两位小数 `100,000.00`

```javascript
// ✅ 正确示例 - listData.js
export const listData = {
  columns: [
    {
      title: '项目名称',
      dataIndex: 'projectName',
      minWidth: 150,
      align: 'left' // 文本左对齐
    },
    {
      title: '状态',
      dataIndex: 'status',
      width: 100,
      align: 'center', // 固定长度居中
      slots: { default: 'featureColumn' }
    },
    {
      title: '金额(元)', // ✅ 单位在表头
      dataIndex: 'amount',
      width: 150,
      align: 'right' // 数字右对齐
    },
    {
      title: '操作',
      key: 'active',
      width: 160,
      fixed: 'right',
      align: 'center',
      slots: { default: 'active' }
    }
  ]
}

// ✅ 数值格式化 - 模板中
<template #featureColumn="{ row, column }">
  <template v-if="column.field == 'amount'">
    {{ row.amount ? row.amount.toLocaleString() : '-' }}
    <!-- 显示：100,000.00 而不是 100000元 -->
  </template>
</template>
```

#### 2. 表格操作列规范

操作列是表格中最常用的功能区域，需要遵循统一的配置标准：

```javascript
// ✅ 正确配置 - 操作列固定配置
{
  title: '操作',
  key: 'active',
  width: 165,        // ⚠️ 固定宽度165px，不要随意修改
  fixed: 'right',    // 固定在右侧
  align: 'left',   // 居左对齐
  slots: { default: 'active' },
  commands: [
    {
      id: 'module:function:edit',
      btnFun: 'edit',
      name: '编辑',
      icon: '',
      type: 'primary'
    },
    {
      id: 'module:function:delete',
      btnFun: 'delete',
      name: '删除',
      icon: '',
      type: 'danger'
    }
  ]
}
```

**配置原则：**
- ✅ 操作列宽度统一为 **165px**
- ✅ 通过 `commands` 配置按钮，不要在模板中额外定义
- ❌ 不要手动在模板中写 `<template #active>`
- ❌ 不要手动在模板中定义序号列 `columns:[{itle: '序号',dataIndex: 'index',width: 80,align: 'center' },...]`

#### 3. 表格列宽配置规范

表格列宽的配置直接影响用户体验，需要合理分配：

```javascript
// ⚠️ 重要规则：width 和 minWidth 不能同时存在
// ⚠️ 至少有一列必须配置 minWidth（自适应）

// ✅ 正确示例
export const listData = {
  columns: [
    {
      title: '项目名称',
      dataIndex: 'projectName',
      minWidth: 150,     // 自适应宽度：文本内容
      resizable: true,   // 允许拖拽调整
      showOverflow: true // 超出显示省略号
    },
    {
      title: '金额(元)',
      dataIndex: 'amount',
      width: 150,        // 固定宽度：数值类型
      align: 'right'
    },
    {
      title: '操作',
      key: 'active',
      width: 160,        // 固定宽度：操作列
      fixed: 'right'
    }
  ]
}

// ❌ 错误示例
{
  title: '序号',
  dataIndex: 'index',
  width: 80,         // 固定宽度：序号、状态等固定内容
  align: 'center'
},
{
  title: '列名',
  dataIndex: 'field',
  width: 200,      // ❌ 不能同时存在
  minWidth: 150    // ❌ 不能同时存在
}
```

**宽度配置指南：**

| 列类型 | 推荐宽度 | 配置方式 | 说明 |
|--------|---------|---------|------|
| 序号 | 60-80px | width | 固定宽度 |
| 勾选框 | 55px | width | 固定宽度 |
| 状态/类型 | 80-120px | width | 固定宽度 |
| 文本内容 | 150-300px | minWidth | 自适应 |
| 日期时间 | 160-180px | width | 固定宽度 |
| 金额/数值 | 120-150px | width | 固定宽度 |
| 操作列 | 160px | width | 固定宽度 |

### 🔘 按钮组件规范（el-button）

#### 1. 按钮尺寸规范

**⚠️ 全局禁令：`src/views` 目录下所有页面的按钮禁止设置 `size` 属性**

```vue
<!-- ✅ 正确方式 - 不设置size，使用全局默认尺寸 -->
<el-button type="primary" @click="handleAdd">新增</el-button>
<el-button type="danger" @click="handleDelete">删除</el-button>
<el-button @click="handleCancel">取消</el-button>

<!-- ❌ 错误方式 - 禁止设置size -->
<el-button type="primary" size="default">新增</el-button>
<el-button type="danger" size="small">删除</el-button>
```

**原因说明：**
- 全局已统一配置按钮尺寸
- 保持整个系统的视觉一致性
- 避免不同页面尺寸不统一

#### 2. 按钮类型与场景

按钮的 `type` 属性应该根据操作类型选择，保持语义化和一致性：

##### 1. 行内按钮配置type
| 操作类型 | type 属性 | 使用场景 | 示例 |
|---------|----------|---------|------|
| 主要操作 | `primary` | 新增、保存、提交、确认 | 新增用户、保存配置 |
| 危险操作 | `danger` | 删除 |
| 警告操作 | `primary` | 导出、下载、重新加载 | 导出数据 |
| 信息操作 | `primary` | 查看、详情 | 查看详情 |

##### 2. 非行内按钮type设置
| 操作类型 | type 属性 | 使用场景 | 示例 |
|---------|----------|---------|------|
| 主要操作 | `primary` | 新增、保存、提交、确认 | 新增用户、保存配置 |
| 危险操作 | `danger` | 删除 |
| 次要操作 | 不设置 | 取消、返回、关闭 | 取消操作、关闭弹窗 |
| 警告操作 | `primary` | 导出、下载、重新加载 | 导出数据 |
| 信息操作 | `primary` | 查看、详情 | 查看详情 |

```vue
<!-- ✅ 正确示例 -->
<!-- 页面顶部操作区 -->
<div class="operation-bar">
  <el-button type="primary" @click="handleAdd">
    <el-icon><Plus /></el-icon>
    新增
  </el-button>
  <el-button @click="handleBatchDelete">
    <el-icon><Delete /></el-icon>
    删除
  </el-button>
  <el-button @click="handleExport">
    <el-icon><Download /></el-icon>
    导出
  </el-button>
</div>

<!-- 表格内按钮必须设置link属性 -->
<el-table :data="tableData">
  <el-table-column label="操作" width="160" fixed="right">
    <template #default="{ row }">
      <el-button type="primary" link @click="handleEdit(row)">
        编辑
      </el-button>
      <el-button type="primary" link @click="handleDelete(row)">
        删除
      </el-button>
    </template>
  </el-table-column>
</el-table>

<!-- el-dialog弹窗footer插槽 -->
<el-dialog v-model="visible" title="编辑信息">
  <el-form>...</el-form>
  <template #footer>
    <div class="dialog-footer">
      <el-button @click="visible = false">取消</el-button>
      <!-- ⚠️ 取消按钮不设置type -->
      <el-button type="primary" @click="handleSave">保存</el-button>
      <el-button type="primary" @click="handleSubmit">保存并提交</el-button>
    </div>
  </template>
</el-dialog>
```

#### 3. 表格内按钮规范

**⚠️ 强制要求：表格内的按钮必须设置 `link` 属性**
**⚠️ 强制要求：表格内的按钮必须设置 `type='primary'` 属性**
**⚠️ 强制要求：表格内的删除按钮必须设置 `type='danger'` 属性**
**⚠️ 强制要求：表格外的按钮[除了：新增]禁止设置 `type=` 属性**
**⚠️ 强制要求：表格外的新增按钮必须设置 `type='primary'` 属性**

```vue
<!-- ✅ 正确方式 - 表格内按钮必须设置link -->
<el-table-column label="操作" width="160" fixed="right" align="center">
  <template #default="{ row }">
    <el-button type="primary" link @click="handleEdit(row)">
      编辑
    </el-button>
    <el-button type="danger" link @click="handleDelete(row)">
      删除
    </el-button>
    <el-button type="primary" link @click="handleView(row)">
      查看
    </el-button>
  </template>
</el-table-column>

<!-- ❌ 错误方式 - 表格内按钮没有link属性 -->
<el-table-column label="操作">
  <template #default="{ row }">
    <el-button type="info" @click="handleEdit(row)">编辑</el-button>
    <!-- 没有link属性，按钮会很突兀 -->
    <!-- type不是primary，按钮风格会不统一 -->
  </template>
</el-table-column>
```

**link 属性的作用：**
- 按钮呈现为文本链接样式，更轻量
- 节省表格空间
- 提升视觉层次感

#### 4. 弹窗按钮规范

弹窗（el-dialog）底部按钮有固定的配置模式：

```vue
<!-- ✅ 标准弹窗按钮配置 -->
<el-dialog
  v-model="visible"
  title="编辑信息"
  :width="MODAL_CONFIG['pro']"
  destroy-on-close
  append-to-body
>
  <el-form>
    <!-- 表单内容 -->
  </el-form>
  
  <template #footer>
    <div class="dialog-footer">
      <!-- 1. 取消按钮：不设置type -->
      <el-button @click="handleCancel">取消</el-button>
      
      <!-- 2. 保存按钮：type="primary" -->
      <el-button type="primary" @click="handleSave">保存</el-button>
      
      <!-- 3. 保存并提交：type="primary" -->
      <el-button type="primary" @click="handleSubmit">
        保存并提交
      </el-button>
    </div>
  </template>
</el-dialog>
```

**弹窗按钮配置规则：**

| 按钮 | type属性 | 位置 | 说明 |
|------|---------|------|------|
| 取消 | **不设置** | 最左侧 | 取消操作，返回 |
| 保存 | `primary` | 中间 | 保存草稿 |
| 保存并提交 | `primary` | 最右侧 | 保存并提交审核 |
| 确认 | `primary` | 最右侧 | 确认操作 |
| 删除（危险） | `danger` | 最右侧 | 删除确认 |

#### 5. 按钮间距规范

**⚠️ 重要：多个按钮排列时，禁止手动设置按钮之间的间距**

```vue
<!-- ✅ 正确方式 - 不设置间距，使用全局样式 -->
<div class="button-group">
  <el-button type="primary">新增</el-button>
  <el-button type="danger">删除</el-button>
  <el-button>导出</el-button>
</div>

<!-- ❌ 错误方式 - 手动设置间距 -->
<div class="button-group">
  <el-button type="primary" style="margin-right: 10px">新增</el-button>
  <el-button type="danger" style="margin-right: 10px">删除</el-button>
  <el-button>导出</el-button>
</div>

<!-- ❌ 错误方式 - 使用el-space -->
<el-space :size="10">
  <el-button type="primary">新增</el-button>
  <el-button type="danger">删除</el-button>
</el-space>
```

**原因说明：**
- 全局CSS已统一配置按钮间距（通常为8px或12px）
- 手动设置会破坏全局一致性
- 便于统一调整间距大小

### 📋 表单组件规范

#### Element Plus 组件配置规范

element-plus 的组件，如果支持 clearable 则必须配置 clearable；el-select 组件必须配置 filterable 属性。

```vue
<!-- ✅ 正确方式 - 支持clearable的组件必须配置 -->
<el-input
  v-model="formData.name"
  placeholder="请输入名称"
  clearable
/>

<el-select
  v-model="formData.type"
  placeholder="请选择类型"
  clearable
  filterable
>
  <el-option
    v-for="item in options"
    :key="item.value"
    :label="item.label"
    :value="item.value"
  />
</el-select>

<el-date-picker
  v-model="formData.date"
  type="date"
  placeholder="请选择日期"
  clearable
/>

<el-tree-select
  v-model="formData.treeValue"
  :data="treeData"
  placeholder="请选择"
  clearable
  filterable
/>

<!-- ❌ 错误方式 - 缺少clearable或filterable -->
<el-input
  v-model="formData.name"
  placeholder="请输入名称"
  <!-- 缺少 clearable -->
/>

<el-select
  v-model="formData.type"
  placeholder="请选择类型"
  clearable
  <!-- 缺少 filterable -->
>
```

**配置说明：**

- **clearable**: 所有支持清除的组件必须配置
- **filterable**: el-select 组件必须配置，支持搜索过滤
- **一致性**: 确保所有表单组件都有统一的交互体验

#### el-input-number 使用规范

数字输入框的配置需要根据业务场景细分：

```vue
<!-- ✅ 金额字段配置 -->
<el-form-item label="金额" prop="amount">
  <el-input-number
    v-model="formData.amount"
    :min="0"
    :max="999999999"
    :precision="2"
    :step="0.01"
    align="left"
    controls-position="right"
    style="width: 100%"
  >
    <template #suffix>元</template>
  </el-input-number>
</el-form-item>

<!-- ✅ 百分比字段配置 -->
<el-form-item label="折扣比例" prop="discount">
  <el-input-number
    v-model="formData.discount"
    :min="0"
    :max="100"
    :precision="2"
    :step="0.01"
    align="left"
    controls-position="right"
    style="width: 100%"
  >
    <template #suffix>%</template>
  </el-input-number>
</el-form-item>

<!-- ✅ 整数字段配置 -->
<el-form-item label="数量" prop="count">
  <el-input-number
    v-model="formData.count"
    :min="0"
    :max="9999"
    :step="1"
    align="left"
    controls-position="right"
    style="width: 100%"
  />
</el-form-item>
```

**配置对照表：**

| 字段类型 | min | max | precision | step | suffix |
|---------|-----|-----|-----------|------|--------|
| 金额 | 0 | 999999999 | 2 | 0.01 | 元 |
| 百分比 | 0 | 100 | 2 | 0.01 | % |
| 面积 | 0 | 999999 | 2 | 0.01 | ㎡ |
| 整数数量 | 0 | 9999 | 无 | 1 | 无 |

**必需配置：**
- ✅ `align="left"` - 左对齐输入
- ✅ `controls-position="right"` - 控制按钮在右侧
- ✅ 有单位时使用 `<template #suffix>单位</template>`
- ❌ 不要把单位写在 label 里

### 💬 消息提示规范

#### 消息提示统一使用 proxy.$modal

**⚠️ 重要规范：任何页面都不得单独引入 ElMessage、ElNotification 等 UI 组件去实现消息的提示**

**核心原则**：
- ✅ 全部采用 `proxy.$modal` 工具函数进行提示
- ✅ 所有特定配置在 `src/plugins/modal.js` 内统一配置，做到全局提示样式一致性
- ❌ 禁止单独引入 ElMessage、ElNotification 等 UI 组件

```vue
<!-- ✅ 正确方式 - 使用 proxy.$modal -->
<script setup>
import { getCurrentInstance } from 'vue';

const { proxy } = getCurrentInstance();

const handleSubmit = async () => {
  try {
    await api.saveData(formData.value);
    proxy.$modal.msgSuccess('操作成功');
  } catch (error) {
    proxy.$modal.msgError('操作失败');
  }
};

const handleDelete = () => {
  proxy.$modal.confirm('确定要删除这条记录吗？').then(() => {
    // 确认删除逻辑
    proxy.$modal.msgSuccess('删除成功');
  });
};

const handleWarning = () => {
  proxy.$modal.msgWarning('请注意此操作');
};

const handleInfo = () => {
  proxy.$modal.msgInfo('提示信息');
};
</script>
```

```vue
<!-- ❌ 错误方式 - 单独引入 ElMessage -->
<script setup>
import { ElMessage, ElNotification } from 'element-plus';

const handleSubmit = async () => {
  try {
    await api.saveData(formData.value);
    // ❌ 禁止：单独使用 ElMessage
    ElMessage.success('操作成功');
  } catch (error) {
    // ❌ 禁止：单独使用 ElMessage
    ElMessage.error('操作失败');
  }
};

const handleNotify = () => {
  // ❌ 禁止：单独使用 ElNotification
  ElNotification({
    title: '通知',
    message: '这是一条通知消息',
    type: 'success'
  });
};
</script>
```

**proxy.$modal 常用方法**：
- `proxy.$modal.msgSuccess(message)` - 成功提示
- `proxy.$modal.msgError(message)` - 错误提示
- `proxy.$modal.msgWarning(message)` - 警告提示
- `proxy.$modal.msgInfo(message)` - 信息提示
- `proxy.$modal.confirm(message)` - 确认对话框

**配置说明**：
- 所有提示样式配置统一在 `src/plugins/modal.js` 中管理
- 确保全局提示样式一致性
- 便于统一调整提示样式和行为

### 🎯 规范总结

#### ✅ 必须遵守的规则

**组件通信规范**：
1. **父子组件传值**：子组件统一使用 `defineModel({type: Object, required: true})` 接收
2. **父组件传值**：父组件定义全量字段的 formData 对象，通过 v-model 传递 formData 整个对象
3. **兄弟组件共享**：通过 `modelValue.value` 访问其他兄弟组件内的属性，实现数据双向绑定/共享
4. **watch 使用**：尽量少使用 watch，必须使用时在页面销毁时解除监听

**样式配置规范**：
5. **样式配置统一**：el-form、el-col、el-dialog 的配置统一使用 `useStyleConfig` hooks
6. **表格对齐**：文本左对齐、数字右对齐、状态居中对齐
7. **单位位置**：表头显示单位，单元格不拼接单位
8. **按钮尺寸**：views 目录下禁止设置 size 属性
9. **表格按钮**：必须设置 link 属性
10. **按钮类型**：新增 primary、删除 danger、取消不设置
11. **弹窗按钮**：取消不设置type，保存/提交 primary
12. **按钮间距**：禁止手动设置，使用全局样式
13. **操作列宽**：固定 160px
14. **列宽配置**：width 和 minWidth 不能同时存在

**消息提示规范**：
15. **消息提示统一**：全部使用 `proxy.$modal` 工具函数，禁止单独引入 ElMessage、ElNotification

#### ❌ 禁止的行为

**组件通信禁止**：
- ❌ 子组件使用 props 接收数据（应使用 defineModel）
- ❌ 传递 formData.List 这种某个属性（应传递完整 formData 对象，除非纯展示）
- ❌ 使用 emit(事件)去更新父组件 formData 内属性
- ❌ watch 监听后不在页面销毁时解除监听

**样式配置禁止**：
- ❌ 手动设置 el-form 的 label-width、布局等配置
- ❌ 手动设置 el-col 的 span 栅格
- ❌ 手动设置 el-dialog 的弹窗宽度
- ❌ 在单元格中拼接单位（如：`100元`、`50%`）
- ❌ 在 views 目录下设置按钮 size 属性
- ❌ 表格内按钮不设置 link 属性
- ❌ 手动设置按钮间距
- ❌ width 和 minWidth 同时配置
- ❌ 操作列宽度不是 160px

**消息提示禁止**：
- ❌ 单独引入 ElMessage、ElNotification 等 UI 组件
- ❌ 使用 ElMessage.success()、ElNotification() 等方法

#### 📝 代码检查清单

在提交代码前，请检查以下项：

**组件通信检查**：
- [ ] 子组件是否使用 defineModel 接收数据
- [ ] 父组件是否传递完整的 formData 对象
- [ ] 是否通过 modelValue.value 实现兄弟组件数据共享
- [ ] watch 监听是否在页面销毁时解除

**样式配置检查**：
- [ ] el-form、el-col、el-dialog 是否使用 useStyleConfig 配置
- [ ] 表格对齐方式是否符合规范
- [ ] 表头是否包含单位，单元格是否未拼接单位
- [ ] 按钮是否未设置 size 属性
- [ ] 表格内按钮是否设置了 link 属性
- [ ] 按钮 type 是否符合操作类型
- [ ] 弹窗底部按钮配置是否正确
- [ ] 按钮间距是否使用全局样式
- [ ] 表格列宽配置是否合理
- [ ] 操作列宽度是否为 160px
- [ ] el-input-number 配置是否完整

**消息提示检查**：
- [ ] 是否使用 proxy.$modal 进行消息提示
- [ ] 是否未单独引入 ElMessage、ElNotification